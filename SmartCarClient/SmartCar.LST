C51 COMPILER V8.02   SMARTCAR                                                              02/01/2018 12:22:40 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE SMARTCAR
OBJECT MODULE PLACED IN SmartCar.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SmartCar.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC15F4K60S4 系列 定时器1用作串口1的波特率发生器举例------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966-------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.GXWMCU.com --------------------------------------------*/
   9          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序        */
  10          /* 如果要在文章中应用此代码,请在文章中注明使用了STC的资料及程序        */
  11          /*---------------------------------------------------------------------*/
  12          
  13          //本示例在Keil开发环境下请选择Intel的8058芯片型号进行编译
  14          //若无特别说明,工作频率一般为11.0592MHz
  15          
  16          
  17          #include "STC15W4K58S4.h"
  18          
  19          #include "intrins.h"
  20          #include <string.h>  // 字符串处理头文件
  21          
  22          sbit LED = P3 ^ 2;  // 对应硬件连接
  23          sbit LOUND = P5 ^ 4;  // 对应硬件连接
  24          
  25          typedef unsigned char BYTE;
  26          typedef unsigned int WORD;
  27          
  28          BYTE DATA_LENGTH =7;
  29          
  30          BYTE DATA_SEND[]={ 0x7E, 0x00,     0,  0,      0,      0,       0x7E};
  31          BYTE DATA_GET[]= { 0x7E, 0x00,     0,  0,      0,      0,       0x7E};
  32          
  33          BYTE all=0;           
  34          
  35          
  36          
  37          #define FOSC 11059200L          //系统频率
  38          #define BAUD 115200             //串口波特率
  39          
  40          #define NONE_PARITY     0       //无校验
  41          #define ODD_PARITY      1       //奇校验
  42          #define EVEN_PARITY     2       //偶校验
  43          #define MARK_PARITY     3       //标记校验
  44          #define SPACE_PARITY    4       //空白校验
  45          
  46          #define PARITYBIT NONE_PARITY   //定义校验位
  47          
  48          
  49          #define S1_S0 0x40              //P_SW1.6
  50          #define S1_S1 0x80              //P_SW1.7
  51          
  52          
  53          bit busy;
  54          
  55          void SendData(BYTE dat);
C51 COMPILER V8.02   SMARTCAR                                                              02/01/2018 12:22:40 PAGE 2   

  56          void  SendString(char *s);
  57          
  58          void UART_TC (unsigned char *str);
  59          void UART_T (unsigned char UART_data); //定义串口发送数据变量
  60          void Get_Data_ONE();
  61          void DELAY_MS(unsigned int timeout);    //@11.0592MHz
  62          void server();
  63          
  64          
  65          void main()
  66          {
  67   1          P0M0 = 0x00;
  68   1          P0M1 = 0x00;
  69   1          P1M0 = 0x00;
  70   1          P1M1 = 0x00;
  71   1          P2M0 = 0x00;
  72   1          P2M1 = 0x00;
  73   1          P3M0 = 0x00;
  74   1          P3M1 = 0x00;
  75   1          P4M0 = 0x00;
  76   1          P4M1 = 0x00;
  77   1          P5M0 = 0x00;
  78   1          P5M1 = 0x00;
  79   1          P6M0 = 0x00;
  80   1          P6M1 = 0x00;
  81   1          P7M0 = 0x00;
  82   1          P7M1 = 0x00;
  83   1      
  84   1       //   ACC = P_SW1;
  85   1      //    ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
  86   1      //    P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
  87   1          
  88   1        ACC = P_SW1;  ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
  89   1        ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
  90   1        P_SW1 = ACC;  
  91   1        
  92   1      //  ACC = P_SW1;
  93   1      //  ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=1
  94   1      //  ACC |= S1_S1;               //(P1.6/RxD_3, P1.7/TxD_3)
  95   1      //  P_SW1 = ACC;  
  96   1      
  97   1      #if (PARITYBIT == NONE_PARITY)
  98   1          SCON = 0x50;                //8位可变波特率
  99   1      #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
                  SCON = 0xda;                //9位可变波特率,校验位初始为1
              #elif (PARITYBIT == SPACE_PARITY)
                  SCON = 0xd2;                //9位可变波特率,校验位初始为0
              #endif
 104   1      
 105   1          AUXR = 0x40;                //定时器1为1T模式
 106   1          TMOD = 0x00;                //定时器1为模式0(16位自动重载)
 107   1          TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
 108   1          TH1 = (65536 - (FOSC/4/BAUD))>>8;
 109   1          TR1 = 1;                    //定时器1开始启动
 110   1          ES = 1;                     //使能串口中断
 111   1          EA = 1;
 112   1            
 113   1      
 114   1        //  UART_TC("STC15F2K60S2\r\nUart Test !\r\n\0");
 115   1        
 116   1        LED = 0;
 117   1        LOUND = 0;
C51 COMPILER V8.02   SMARTCAR                                                              02/01/2018 12:22:40 PAGE 3   

 118   1          
 119   1          DELAY_MS(2000);
 120   1           server();
 121   1      all=0;
 122   1      DELAY_MS(2000);
 123   1            SendString(DATA_SEND);
 124   1      
 125   1          while(1){
 126   2      
 127   2      
 128   2      
 129   2      DELAY_MS(2000);
 130   2            SendString(DATA_GET);
 131   2      };
 132   1      }
 133          
 134          /*----------------------------
 135          UART 中断服务程序
 136          -----------------------------*/
 137          void Uart() interrupt 4 using 1
 138          {
 139   1          if (RI)
 140   1          {
 141   2              while(!RI);
 142   2              RI=0;
 143   2              Get_Data_ONE();
 144   2                busy = 0; 
 145   2             
 146   2          }
 147   1             if (TI)
 148   1          {
 149   2              while(!TI);
 150   2              TI = 0;                 //清除TI位
 151   2              busy = 0;               //清忙标志
 152   2          }
 153   1      }
 154          
 155          /*----------------------------
 156          发送串口数据
 157          ----------------------------*/
 158          void SendData(BYTE dat)
 159          {
 160   1          while (busy);               //等待前面的数据发送完成
 161   1          ACC = dat;                  //获取校验位P (PSW.0)
 162   1          if (P)                      //根据P来设置校验位
 163   1          {
 164   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 0;                //设置校验位为0
              #elif (PARITYBIT == EVEN_PARITY)
                      TB8 = 1;                //设置校验位为1
              #endif
 169   2          }
 170   1          else
 171   1          {
 172   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 1;                //设置校验位为1
              #elif (PARITYBIT == EVEN_PARITY)
                      TB8 = 0;                //设置校验位为0
              #endif
 177   2          }
 178   1          busy = 1;
 179   1          SBUF = ACC;                 //写数据到UART数据寄存器
C51 COMPILER V8.02   SMARTCAR                                                              02/01/2018 12:22:40 PAGE 4   

 180   1      }
 181          
 182          
 183          /*----------------------------
 184          发送字符串
 185          ----------------------------*/
 186          
 187          void  SendString(char *s)
 188          {
 189   1         unsigned int i=0;
 190   1           
 191   1             for(i=0;i<DATA_LENGTH;i++)          //发test数据 发送至PC端
 192   1             {
 193   2                SBUF=s[i];
 194   2                while(!TI);
 195   2                TI=0;
 196   2             }
 197   1      }
 198          
 199          void UART_T (unsigned char UART_data){ //定义串口发送数据变量
 200   1        SBUF = UART_data; //将接收的数据发送回去
 201   1        while(TI == 0);   //检查发送中断标志位
 202   1        TI = 0;     //令发送中断标志位为0（软件清零）
 203   1      }
 204          
 205          void UART_TC (unsigned char *str){
 206   1        while(*str != '\0'){
 207   2          UART_T(*str);
 208   2          *str++;
*** WARNING C275 IN LINE 208 OF SMARTCAR.C: expression with possibly no effect
 209   2        }
 210   1        *str = 0;
 211   1      }
 212          
 213          
 214          //串口  接收到的数据
 215          
 216          void Get_Data_ONE()  
 217          {
 218   1      
 219   1          DATA_GET[all]=SBUF;
 220   1          all++;
 221   1          if(all==DATA_LENGTH)
 222   1          {
 223   2            all=0;
 224   2            if(DATA_GET[1]==0x03 && DATA_GET[4]==0x02){
 225   3              LED = 1;
 226   3            }else if(DATA_GET[1]==0x03 && DATA_GET[4]==0x01){
 227   3              LED = 0;
 228   3            }else if(DATA_GET[1]==0x02 && DATA_GET[4]==0x02){
 229   3              LOUND = 1;
 230   3            }else if(DATA_GET[1]==0x02 && DATA_GET[4]==0x01){
 231   3              LOUND = 0;
 232   3            }
 233   2              
 234   2            SendString(DATA_GET);
 235   2      
 236   2          
 237   2            }
 238   1      }
 239          
 240          void DELAY_1MS(){
C51 COMPILER V8.02   SMARTCAR                                                              02/01/2018 12:22:40 PAGE 5   

 241   1      unsigned char i, j;
 242   1      
 243   1        _nop_();
 244   1        _nop_();
 245   1        _nop_();
 246   1        i = 11;
 247   1        j = 190;
 248   1        do
 249   1        {
 250   2          while (--j);
 251   2        } while (--i);
 252   1        
 253   1      
 254   1      }
 255          
 256          void DELAY_MS(unsigned int timeout)   //@11.0592MHz
 257          {
 258   1          int t = 0;
 259   1        while (t < timeout)
 260   1        {
 261   2          t++;
 262   2        
 263   2        DELAY_1MS();
 264   2        
 265   2      }
 266   1      }
 267          
 268          void server(){
 269   1      
 270   1      
 271   1        UART_TC("+++\0"); // 退出透传模式
 272   1        DELAY_MS( 1500);
 273   1      
 274   1        UART_TC("AT\r\n\0");  // AT指令测试
 275   1        DELAY_MS(1500);
 276   1      
 277   1        //UART_TC("AT+CWSTARTSMART\r\n\0"); // 开始智能配网模式
 278   1        //DELAY_MS(1000);
 279   1      //  LED = 0; // 配网指示灯亮起
 280   1      //  DELAY_MS( 30000); // 链接成功
 281   1      
 282   1        //UART_TC("AT+CWSTOPSMART\r\n\0"); // 结束智能配网模式，释放模块资源(必须)
 283   1       // DELAY_MS( 1000);
 284   1        //LED = 1; // 配网指示灯熄灭
 285   1      
 286   1        UART_TC("AT+CIPMUX=0\r\n\0");  // 设置单连接模式
 287   1        DELAY_MS(1500);
 288   1      
 289   1        UART_TC("AT+CIPSTART=\"TCP\",\"192.168.0.104\",4001\r\n\0");  // 连接到指定TCP服务器
 290   1        DELAY_MS( 3500);
 291   1      
 292   1        UART_TC("AT+CIPMODE=1\r\n\0"); // 设置透传模式
 293   1        DELAY_MS( 1500);
 294   1      
 295   1        UART_TC("AT+SAVETRANSLINK=1,\"192.168.0.104\",4001,\"TCP\"\r\n\0"); // 保存TCP连接到flash，实现上电透传
 296   1        DELAY_MS(1500);
 297   1      
 298   1        UART_TC("AT+CIPSEND\r\n\0");   // 进入透传模式
 299   1        DELAY_MS( 1500);
 300   1      
 301   1      
 302   1      }
C51 COMPILER V8.02   SMARTCAR                                                              02/01/2018 12:22:40 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    439    ----
   CONSTANT SIZE    =    147    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
