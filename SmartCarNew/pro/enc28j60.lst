C51 COMPILER V8.02   ENC28J60                                                              01/29/2018 14:30:31 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE ENC28J60
OBJECT MODULE PLACED IN ..\debug\enc28j60.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\code\enc28j60.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\enc28j60.lst) TA
                    -BS(2) OBJECT(..\debug\enc28j60.obj)

line level    source

   1          #include "uipopt.h"
   2          #include "enc28j60.h"
   3          #include "spi.h"
   4          
   5          #define MIN(a,b) (a) < (b) ? (a) : (b)
   6          idata u8_t Enc28j60Bank;
   7          idata u16_t NextPacketPtr;
   8          
   9          /// ENC28J60 
  10          void delay_us(int t1)
  11          {
  12   1        while(t1--);
  13   1      }
  14          
  15          void delay_ms(int t1)
  16          { 
  17   1        idata int i; 
  18   1        while(t1--) 
  19   1        {
  20   2          i=100;
  21   2          while(i--);
  22   2        }
  23   1      }
  24          
  25          u8_t enc28j60ReadOp(u8_t op, u8_t address)
  26          {
  27   1        u8_t dat1;
  28   1        // activate CS  
  29   1        CSN =0;
  30   1        // issue read command
  31   1        WriteByte(op | (address & ADDR_MASK));  
  32   1        dat1 = ReadByte();
  33   1        // do dummy read if needed (for mac and mii, see datasheet page 29)
  34   1        if(address & 0x80)  dat1 = ReadByte();
  35   1        // release CS
  36   1        CSN=1;
  37   1        return(dat1);
  38   1      }
  39          
  40          void enc28j60WriteOp(u8_t op, u8_t address, u8_t mydat)
  41          {
  42   1        CSN=0;
  43   1        // issue write command
  44   1        WriteByte( op | (address & ADDR_MASK));
  45   1        // write data
  46   1        WriteByte(mydat);
  47   1        CSN=1;
  48   1      }
  49          
  50          void enc28j60SetBank(u8_t address)
  51          {
  52   1        if((address & BANK_MASK) != Enc28j60Bank)
  53   1        {
  54   2          enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
C51 COMPILER V8.02   ENC28J60                                                              01/29/2018 14:30:31 PAGE 2   

  55   2          enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
  56   2          Enc28j60Bank = (address & BANK_MASK);
  57   2        }
  58   1      }
  59          
  60          u8_t enc28j60Read(u8_t address)
  61          {
  62   1        enc28j60SetBank(address); 
  63   1        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
  64   1      }
  65          
  66          void enc28j60Write(u8_t address, u8_t mydat)
  67          {
  68   1        enc28j60SetBank(address);
  69   1        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, mydat);
  70   1      }
  71          
  72          u16_t enc28j60_read_phyreg(u8_t address)
  73          {
  74   1        u16_t mydat;
  75   1        enc28j60Write(MIREGADR, address);
  76   1        enc28j60Write(MICMD, MICMD_MIIRD);
  77   1        
  78   1        // Loop to wait until the PHY register has been read through the MII
  79   1        // This requires 10.24us
  80   1        while( (enc28j60Read(MISTAT) & MISTAT_BUSY) );
  81   1        
  82   1        // Stop reading
  83   1        enc28j60Write(MICMD, MICMD_MIIRD);
  84   1        
  85   1        // Obtain results and return
  86   1        mydat = enc28j60Read ( MIRDL );
  87   1        mydat |= enc28j60Read ( MIRDH );
  88   1      
  89   1        return mydat;
  90   1      }
  91          
  92          void enc28j60PhyWrite(u8_t address, u16_t mydat)
  93          {
  94   1        // set the PHY register address
  95   1        enc28j60Write(MIREGADR, address);
  96   1        // write the PHY data
  97   1        enc28j60Write(MIWRL, mydat & 0x00ff);
  98   1        enc28j60Write(MIWRH, mydat >> 8);
  99   1        // wait until the PHY write completes
 100   1        while(enc28j60Read(MISTAT) & MISTAT_BUSY)
 101   1        {
 102   2          delay_us(15);
 103   2        }
 104   1      }
 105          
 106          void enc28j60ReadBuffer(u16_t len, u8_t* dat)
 107          {
 108   1      
 109   1        CSN = 0;
 110   1        WriteByte(ENC28J60_READ_BUF_MEM);
 111   1        while(len--)
 112   1        {
 113   2          *dat++ = ReadByte();
 114   2        } 
 115   1        CSN = 1;
 116   1      }
C51 COMPILER V8.02   ENC28J60                                                              01/29/2018 14:30:31 PAGE 3   

 117          
 118          void enc28j60WriteBuffer(u16_t len, u8_t* dat)
 119          {
 120   1        CSN = 0;
 121   1        WriteByte(ENC28J60_WRITE_BUF_MEM);
 122   1        while(len--)
 123   1        {
 124   2          WriteByte(*dat++);
 125   2        } 
 126   1        CSN = 1;
 127   1      }
 128          
 129          #define ETHERNET_MIN_PACKET_LENGTH  0x3C
 130          #define ETHERNET_HEADER_LENGTH    0x0E
 131          
 132          #define IP_TCP_HEADER_LENGTH 40
 133          #define TOTAL_HEADER_LENGTH (IP_TCP_HEADER_LENGTH+ETHERNET_HEADER_LENGTH)
 134          
 135          void enc28j60PacketSend(u16_t len, u8_t* packet)
 136          {
 137   1        // Set the write pointer to start of transmit buffer area
 138   1        enc28j60Write(EWRPTL, TXSTART_INIT);
 139   1        enc28j60Write(EWRPTH, TXSTART_INIT>>8);
 140   1      
 141   1        // Set the TXND pointer to correspond to the packet size given
 142   1        enc28j60Write(ETXNDL, (TXSTART_INIT+len));
 143   1        enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
 144   1      
 145   1        // write per-packet control byte
 146   1        enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
 147   1      
 148   1        // TODO, fix this up
 149   1      
 150   1        if( uip_len <= TOTAL_HEADER_LENGTH )
 151   1        {
 152   2          // copy the packet into the transmit buffer
 153   2          enc28j60WriteBuffer(len, packet);
 154   2        }
 155   1        else
 156   1        {
 157   2          len -= TOTAL_HEADER_LENGTH;
 158   2          enc28j60WriteBuffer(TOTAL_HEADER_LENGTH, packet);
 159   2          enc28j60WriteBuffer(len, (unsigned char *)uip_appdata);
 160   2        }
 161   1        // send the contents of the transmit buffer onto the network
 162   1        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
 163   1      }
 164          
 165          
 166          
 167          
 168          u16_t enc28j60PacketReceive(u16_t maxlen, u8_t* packet)
 169          {
 170   1        u16_t rxstat;
 171   1        u16_t len;
 172   1        u16_t rs,re;
 173   1      
 174   1        // check if a packet has been received and buffered
 175   1        if( !(enc28j60Read(EIR) & EIR_PKTIF) )
 176   1        {
 177   2          // Errata workaround #6, PKTIF is not reliable
 178   2          // double check by looking at EPKTCNT
C51 COMPILER V8.02   ENC28J60                                                              01/29/2018 14:30:31 PAGE 4   

 179   2          if (enc28j60Read(EPKTCNT) == 0)
 180   2            return 0;
 181   2        }
 182   1      
 183   1        // Set the read pointer to the start of the received packet
 184   1        enc28j60Write(ERDPTL, (NextPacketPtr));
 185   1        enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
 186   1      
 187   1        // read the next packet pointer
 188   1        NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 189   1        NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 190   1      
 191   1        // read the packet length
 192   1        len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 193   1        len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 194   1      
 195   1        // read the receive status
 196   1        rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
 197   1        rxstat |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
 198   1      
 199   1        // limit retrieve length
 200   1        // (we reduce the MAC-reported length by 4 to remove the CRC)
 201   1        len = MIN(len, maxlen);
 202   1      
 203   1        // copy the packet from the receive buffer
 204   1        enc28j60ReadBuffer(len, packet);
 205   1        rs = enc28j60Read(ERXSTH);
 206   1        rs <<= 8;
 207   1        rs |= enc28j60Read(ERXSTL);
 208   1        re = enc28j60Read(ERXNDH);
 209   1        re <<= 8;
 210   1        re |= enc28j60Read(ERXNDL);
 211   1        if (NextPacketPtr - 1 < rs || NextPacketPtr - 1 > re)
 212   1        {
 213   2          enc28j60Write(ERXRDPTL, (re));
 214   2          enc28j60Write(ERXRDPTH, (re)>>8);
 215   2        }
 216   1        else
 217   1        {
 218   2          enc28j60Write(ERXRDPTL, (NextPacketPtr-1));
 219   2          enc28j60Write(ERXRDPTH, (NextPacketPtr-1)>>8);
 220   2        }
 221   1      
 222   1        // decrement the packet counter indicate we are done with this packet
 223   1        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
 224   1      
 225   1        return len;
 226   1      }
 227          
 228          void dev_init(void)
 229          {
 230   1        enc28j60_init();
 231   1      }
 232          
 233          void dev_send(void)
 234          {
 235   1        enc28j60PacketSend(uip_len, uip_buf);
 236   1      }
 237          
 238          u16_t dev_poll(void)
 239          {
 240   1        return enc28j60PacketReceive(UIP_BUFSIZE, uip_buf);
C51 COMPILER V8.02   ENC28J60                                                              01/29/2018 14:30:31 PAGE 5   

 241   1      }
 242          
 243          void enc28j60_init(void)
 244          {
 245   1        // perform system reset
 246   1        enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
 247   1        delay_ms(5);
 248   1      
 249   1        // set receive buffer start address
 250   1        NextPacketPtr = RXSTART_INIT;
 251   1        enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
 252   1        enc28j60Write(ERXSTH, RXSTART_INIT>>8);
 253   1      
 254   1        // set receive pointer address
 255   1        enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
 256   1        enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
 257   1      
 258   1        // set receive buffer end
 259   1        // ERXND defaults to 0x1FFF (end of ram)
 260   1        enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
 261   1        enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
 262   1      
 263   1        // set transmit buffer start
 264   1        // ETXST defaults to 0x0000 (beginnging of ram)
 265   1        enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
 266   1        enc28j60Write(ETXSTH, TXSTART_INIT>>8);
 267   1      
 268   1        // do bank 2 stuff
 269   1        // enable MAC receive
 270   1        enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
 271   1      
 272   1        // bring MAC out of reset
 273   1        enc28j60Write(MACON2, 0x00);
 274   1      
 275   1        // enable automatic padding and CRC operations
 276   1        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
 277   1      
 278   1        // set inter-frame gap (non-back-to-back)
 279   1        enc28j60Write(MAIPGL, 0x12);
 280   1        enc28j60Write(MAIPGH, 0x0C);
 281   1        // set inter-frame gap (back-to-back)
 282   1        enc28j60Write(MABBIPG, 0x12);
 283   1        // Set the maximum packet size which the controller will accept
 284   1        enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);  
 285   1        enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
 286   1      
 287   1        // do bank 3 stuff
 288   1        // write MAC address
 289   1        // NOTE: MAC address in ENC28J60 is byte-backward
 290   1        enc28j60Write(MAADR5, UIP_ETHADDR0);
 291   1        enc28j60Write(MAADR4, UIP_ETHADDR1);
 292   1        enc28j60Write(MAADR3, UIP_ETHADDR2);
 293   1        enc28j60Write(MAADR2, UIP_ETHADDR3);
 294   1        enc28j60Write(MAADR1, UIP_ETHADDR4);
 295   1        enc28j60Write(MAADR0, UIP_ETHADDR5);
 296   1      
 297   1        // no loopback of transmitted frames
 298   1        enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
 299   1      
 300   1        // switch to bank 0
 301   1        enc28j60SetBank(ECON1);
 302   1      
C51 COMPILER V8.02   ENC28J60                                                              01/29/2018 14:30:31 PAGE 6   

 303   1        // enable interrutps
 304   1        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
 305   1      
 306   1        // enable packet reception
 307   1        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
 308   1      }
 309          
 310          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1190    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      3       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
